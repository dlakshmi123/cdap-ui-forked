/**
 * Copyright (c) to YOUR_COMPANY. All rights reserved. 
 */
<%@ jet
    class = "TemporaryTemplateCreator" 
	 imports="java.util.* com.continuuity.flow.devtools.eclipse.templates.FileTemplateConfig" 
	 skeleton="TemplateSkeleton.skeleton"
%>
<% FileTemplateConfig templateConfig = (FileTemplateConfig)argument1; %>
<% String templateName = templateConfig.getName(); %>

<% List<String> imports = templateConfig.getImports(); 
	for(int i=0;i<imports.size();i++) { %>
import <%=imports.get(i)%>;
<%	} %>

import java.util.Random;

/**
 * This class represents the simple implementation of a Flow definition.
 *
 * @author (Your Name Here ) 
 */
public class <%=templateName.replace(" ","")%> implements Flow {

  /**
   * Configures a flow by specifying meta information for a flow 
   * along with how the flow is actually connected. 
   */ 
  public void configure(FlowSpecifier specifier) {
    // Provide meta information of a flow. 
    specifier.name("<Provider Flow Name - Only allowed A-Za-z>");
    specifier.application("<Application the flow belongs to>");
    specifier.email("<Email ID to be used for notification for a flow>");
    
    // If there are streams connecting to flow, specify them here. 
    // specifier.stream("<Stream Name>");
    
    // Assign each implementation of a flowlet a name. 
    specifier.flowlet("RandomNumberGenerator", RandomNumberGenerator.class);
    specifier.flowlet("RunningAggregate", RunningAggregate.class);
    specifier.flowlet("StoreRunningAggregate", StoreRunningAggregate.class);
    
    // Connect the stream to the source flowlet. 
    // specifier.input("<Stream Name>", "RandomNumberGenerator");
    
    // Now specify how the flowlets are connected to each other. 
    specifier.connection("RandomNumberGenerator", "RunningAggregate");
    specifier.connection("RunningAggregate", "StoreRunningAggregate");
  }
}

/**
 * Source flowlet that emits random numbers continuously.
 * 
 * A source flowlet is a type of flowlet that has no input streams
 * but has only output streams specified.  
 */
class RandomNumberGenerator extends AbstractSourceFlowlet {

  /**
   * Random number generator.
   */
  private Random random;

  /**
   * Initializes a flowlet. 
   * 
   * NOTE: Initialization is called by the framework only once during 
   * starting up of a flowlet. 
   */
  @Override
  public void initialize(FlowletLaunchContext launchContext) {
  	super.initialize(launchContext);
  	this.random = new Random();
  } 
  
  /**
   * Configures the output stream of a flowlet. 
   * In this example an output stream has only one field named 'randomNumber'
   * with type Long.
   *
   * NOTE: SourceFlowlet#configure might be called more than once. It's called
   * during deployment and verification of a flow and also during execution. 
   *
   * WARNING : Make sure you do not performance any resource initialization required
   * by the flowlet here. 
   */
  @Override
  public void configure(StreamsConfigurator configurator) {
    TupleSchema out = new TupleSchemaBuilder().
    	add("randomNumber", Long.class).
    	create();
    configurator.getDefaultTupleOutputStream().setSchema(out);
  }
  
  /**
   * Generates the input data. 
   *
   * NOTE: SourceFlowlet#generate is invoked as fast the framework can to generate 
   * data. In order to slow it down it's the responsibility of 
   */
  @Override
  public void generate(OutputCollector collector) {
  	long randomNumber = Math.abs(this.random.nextLong());
  	Tuple randomNumberTuple = new TupleBuilder()
  		.set("randomNumber", randomNumber)
  		.create();
  	collector.add(randomNumberTuple);
  }
}

/**
 * A compute flowlet that emits sum of the random numbers generated by 
 * the 'RandomNumberGenerator' flowlet. 
 */
class RunningAggregate extends AbstractComputeFlowlet {

  /**
   * Stores the running aggregate of numbers.
   */
  private Long runningAggreate = new Long(0);

  /**
   * Configures the output stream of a flowlet. 
   * In this example an output stream has only one field named 'randomNumber'
   * with type Long.
   *
   * NOTE: SourceFlowlet#configure might be called more than once. It's called
   * during deployment and verification of a flow and also during execution. 
   *
   * WARNING : Make sure you do not performance any resource initialization required
   * by the flowlet here. 
   */
   
  @Override
  public void configure(StreamsConfigurator configurator) {
    // Defines the schema for the input stream.
    TupleSchema in = new TupleSchemaBuilder().
        add("randomNumber", Long.class).
        create();
    
    // Defines the schema for the output stream. 
    TupleSchema out = new TupleSchemaBuilder().
    	add("runningAggregate", Long.class).
    	create();
    	
    // Sets the input and output schemas on the stream. 
    configurator.getDefaultTupleInputStream().setSchema(in);
    configurator.getDefaultTupleOutputStream().setSchema(out);
  }

  /**
   * ComputeFlowlet#process is invoked when there is a tuple available on input 
   * stream for processing. A context of tuple providing information about where 
   * the tuple came from is passed along with tuple in 'TupleContext'. 
   */
  @Override
  public void process(Tuple tuple, TupleContext tupleContext,
      OutputCollector collector) {
    Long number = tuple.get("randomNumber");
    runningAggregate += number;
    
    // Emit the aggregate of the tuple. 
    Tuple runningAggregateTuple = new TupleBuilder()
  		.set("runningAggregate", runningAggregate)
  		.create();
  		
    // emit the increment operation
    collector.add(runningAggregate);
  }
}

/**
 * Stores the running aggregates passed along from 'RunningAggregate' flowlet 
 * into data fabric.
 */ 
class StoreRunningAggregate extends AbstractComputeFlowlet {
  
  /**
   * Configures the output stream of a flowlet. 
   * In this example an output stream has only one field named 'randomNumber'
   * with type Long.
   *
   * NOTE: SourceFlowlet#configure might be called more than once. It's called
   * during deployment and verification of a flow and also during execution. 
   *
   * WARNING : Make sure you do not performance any resource initialization required
   * by the flowlet here. 
   */
   
  @Override
  public void configure(StreamsConfigurator configurator) {
    // Defines the schema for the input stream. 
    TupleSchema in = new TupleSchemaBuilder().
    	add("runningAggregate", Long.class).
    	create();
    	
    // Sets the input and output schemas on the stream. 
    configurator.getDefaultTupleInputStream().setSchema(in);
  }
  
  /**
   * ComputeFlowlet#process is invoked when there is a tuple available on input 
   * stream for processing. A context of tuple providing information about where 
   * the tuple came from is passed along with tuple in 'TupleContext'. 
   */  
  @Override
  public void process(Tuple tuple, TupleContext tupleContext,
  	OutputCollector collector) {
  	Long runningAggregate = tuple.get("runningAggregate");
  	byte[] key = "running-aggregate".getBytes();
  	byte[] value = runningAggregate.toString().getBytes();
  	collector.add(new Write(key, value);
  }
  
}